package rss

import (
	"crypto/sha256"
	"encoding/base64"
	"encoding/xml"
	"fmt"
	"frontend-gafam/service/common"
	"regexp"
	"sniffle/tool"
	"sniffle/tool/fetch"
	"strconv"
	"strings"
	"time"
)

func Fetch(t *tool.Tool, url string) *common.List {
	dto := struct{ XMLName xml.Name }{}
	data := tool.FetchAll(t, fetch.URL(url))
	if err := xml.Unmarshal(data, &dto); err != nil {
		t.Warn("xml.decode", "url", url, "err", err.Error())
		return nil
	}

	switch dto.XMLName.Local {
	case "rss":
		return rss(t, url, data)
	case "feed":
		return atom(t, url, data)
	default:
		fmt.Println("rss.unknowntype", "type", dto.XMLName.Local)
		return nil
	}
}

func rss(t *tool.Tool, url string, data []byte) *common.List {
	dto := struct {
		Channel struct {
			Title       string `xml:"title"`
			Link        string `xml:"link"`
			Description string `xml:"description"`
			Item        []struct {
				Title       string  `xml:"title"`
				Link        string  `xml:"link"`
				Description string  `xml:"description"`
				PubDate     rssTime `xml:"pubDate"`
				Author      string  `xml:"author"`
				Duration    string  `xml:"duration"`
				Enclosure   struct {
					URL    string `xml:"url,attr"`
					Type   string `xml:"type,attr"`
					Length int    `xml:"length,attr"`
				} `xml:"enclosure"`
				Image struct {
					Href string `xml:"href,attr"`
				} `xml:"image"`
			} `xml:"item"`
		} `xml:"channel"`
	}{}

	if err := xml.Unmarshal(data, &dto); err != nil {
		t.Warn("xml.decode", "url", url, "err", err.Error())
		return nil
	}

	list := &common.List{
		Host:        "rss",
		ID:          genID(url),
		URL:         dto.Channel.Link,
		Title:       dto.Channel.Title,
		Description: common.Description(dto.Channel.Description),
		Items:       make([]*common.Item, len(dto.Channel.Item)),
	}
	for i, dto := range dto.Channel.Item {
		poster, posterWidth, posterHeight := common.FetchPoster(t, dto.Image.Href)
		if len(poster) == 0 {
			poster, posterWidth, posterHeight = common.TextPoster(dto.Link)
		}

		item := &common.Item{
			Host:        "rss",
			ID:          genID(dto.Link),
			URL:         dto.Link,
			Title:       dto.Title,
			Description: common.Description(dto.Description),
			Author:      dto.Author,
			Published:   dto.PubDate.Time,

			Poster:       poster,
			PosterWidth:  posterWidth,
			PosterHeight: posterHeight,
		}

		if dto.Enclosure.Type == "audio/mpeg" {
			item.IsVideo = true
			item.Sources = []common.Source{{Name: "audio", URL: dto.Enclosure.URL}}

			if dto.Duration == "" {
				item.Duration = time.Duration(dto.Enclosure.Length) * time.Second
			} else if durationColon.MatchString(dto.Duration) {
				h, m, s := 0, 0, 0
				fmt.Sscanf(dto.Duration, "%d:%d:%d", &h, &m, &s)
				item.Duration = time.Duration(h)*time.Hour +
					time.Duration(m)*time.Minute +
					time.Duration(s)*time.Second
			} else if durationInt.MatchString(dto.Duration) {
				d, _ := strconv.Atoi(strings.TrimSuffix(dto.Duration, "\""))
				item.Duration = time.Duration(d) * time.Second
			} else {
				t.Warn("wrongDurationFormat", "s", dto.Duration)
			}
		}

		list.Items[i] = item
	}

	return list
}

var durationColon = regexp.MustCompile(`^\d\d:\d\d:\d\d$`)
var durationInt = regexp.MustCompile(`^\d+"?$`)

type rssTime struct {
	time.Time
}

func (t *rssTime) UnmarshalText(text []byte) (err error) {
	s := string(text)
	if strings.HasSuffix(s, " GMT") {
		t.Time, err = time.Parse(time.RFC1123, s)
	} else {
		t.Time, err = time.Parse(time.RFC1123Z, s)
	}
	return
}

func genID(s string) string {
	h := sha256.Sum224([]byte(s))
	return base64.RawURLEncoding.EncodeToString(h[:])
}
